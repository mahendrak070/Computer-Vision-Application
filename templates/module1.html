<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 1 - Dimension Estimation</title>
    <link rel="stylesheet" href="/static/css/module.css">
</head>
<body>
    <div class="header">
        <h1>Module 1: Real-World Dimension Estimation</h1>
        <a href="/dashboard" class="back-btn">Back to Dashboard</a>
    </div>

    <div class="container">
        <div class="section">
            <h2>Dimension Estimation</h2>
            <div class="info-box">
                <strong>How it works:</strong> This module measures real-world dimensions using camera calibration and perspective projection. Lens distortion is automatically corrected.
                <br><br>
                <strong>Instructions:</strong>
                <ol style="margin: 8px 0 0 20px; line-height: 1.8;">
                    <li>Upload an image - it will be automatically undistorted</li>
                    <li><strong>FIRST:</strong> Click 2 points on an object</li>
                    <li>Enter the actual length in (inches)"</li>
                    <li>Click <strong>"Calibrate"</strong> to set the scale</li>
                    <li>Now click additional points to measure other distances (up to 4 points total)</li>
                    <li>All measurements will be calculated based on the calibrated scale</li>
                    <li>Click Reset to start over</li>
                </ol>
            </div>

            <div class="controls">
                <input type="file" id="imageInput" accept="image/*" onchange="loadImage(event)" style="display: none;">
                <button class="btn-primary" onclick="document.getElementById('imageInput').click()">Upload Image</button>
                <button class="btn-secondary" onclick="resetCalculation()">Reset</button>
                <span id="loadingIndicator" style="display: none; margin-left: 16px; color: #64ffda;">
                    Processing image...
                </span>
            </div>

            <div class="grid">
                <div>
                    <h3>Image Canvas <span style="font-size: 12px; color: #64ffda; font-weight: normal;">(Lens distortion corrected)</span></h3>
                    <canvas id="canvas" width="800" height="600" style="cursor: crosshair;"></canvas>
                </div>
                <div>
                    <div class="stats">
                        <h3>Calibration</h3>
                        <div>
                            <label>Known Length (inches):</label>
                            <input type="number" id="referenceLength" value="4" min="0.1" step="0.1">
                        </div>
                        <div style="margin-top: 12px;">
                            <button class="btn-primary" onclick="setReference()" id="setRefBtn" disabled>Calibrate</button>
                            <small style="display: block; margin-top: 8px; font-size: 11px; color: #64ffda;" id="calibStatus">Click 2 points first</small>
                        </div>
                        <div style="margin-top: 12px;">
                            <label>Scale Factor (px/in):</label>
                            <input type="text" id="scaleFactor" value="Not calibrated" readonly style="background: rgba(100, 255, 218, 0.05); cursor: not-allowed;">
                        </div>
                    </div>
                    <div class="stats" style="margin-top: 16px;">
                        <h3>Results</h3>
                        <div class="stat-item">
                            <span class="stat-label">Points Selected:</span>
                            <span class="stat-value" id="pointCount">0/4</span>
                        </div>
                        <div id="measurementsContainer"></div>
                    </div>
                </div>
            </div>

            <div class="progress-container" id="progressContainer">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill">0%</div>
                </div>
                <div class="progress-text" id="progressText">Processing...</div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let points = [];
        let image = null;
        let pixelsPerInch = null;
        let isCalibrated = false;

        async function loadImage(event) {
            const file = event.target.files[0];
            if (!file) return;

            const loadingIndicator = document.getElementById('loadingIndicator');
            loadingIndicator.style.display = 'inline';

            const reader = new FileReader();
            reader.onload = async function(e) {
                const originalImageData = e.target.result;
                
                const loadOriginalImage = () => {
                    image = new Image();
                    image.onload = function() {
                        canvas.width = Math.min(image.width, 800);
                        canvas.height = (canvas.width / image.width) * image.height;
                        drawImage();
                        loadingIndicator.style.display = 'none';
                        console.log('âœ… Image loaded (original)');
                    };
                    image.onerror = function() {
                        loadingIndicator.style.display = 'none';
                        alert('Failed to load image');
                    };
                    image.src = originalImageData;
                };
                
                try {
                    console.log('ðŸ”„ Attempting to undistort image...');
                    const response = await fetch('/api/module1/undistort', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ image: originalImageData })
                    });
                    
                    if (!response.ok) {
                        console.warn('âš ï¸ Undistortion API error, using original image');
                        loadOriginalImage();
                        return;
                    }
                    
                    const data = await response.json();
                    
                    if (data.success && data.undistorted_image) {
                        image = new Image();
                        image.onload = function() {
                            canvas.width = Math.min(image.width, 800);
                            canvas.height = (canvas.width / image.width) * image.height;
                            drawImage();
                            loadingIndicator.style.display = 'none';
                            console.log('âœ… Image undistorted and loaded successfully');
                        };
                        image.onerror = function() {
                            console.error('âŒ Failed to load undistorted image, using original');
                            loadOriginalImage();
                        };
                        image.src = 'data:image/jpeg;base64,' + data.undistorted_image;
                    } else {
                        console.warn('âš ï¸ Undistortion failed:', data.message || 'Unknown error');
                        loadOriginalImage();
                    }
                } catch (error) {
                    console.error('âŒ Error during undistortion:', error);
                    console.log('ðŸ”„ Falling back to original image');
                    loadOriginalImage();
                }
            };
            reader.readAsDataURL(file);
            resetPoints();
        }

        function drawImage() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (image) {
                ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
                drawPoints();
            }
        }

        function drawPoints() {
            points.forEach((point, index) => {
                ctx.shadowColor = '#00f7ff';
                ctx.shadowBlur = 15;
                
                ctx.fillStyle = '#00f7ff';
                ctx.beginPath();
                ctx.arc(point.x, point.y, 8, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#0a0e27';
                ctx.beginPath();
                ctx.arc(point.x, point.y, 4, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 16px Inter';
                ctx.strokeStyle = '#0a0e27';
                ctx.lineWidth = 3;
                ctx.strokeText(index + 1, point.x + 12, point.y - 8);
                ctx.fillText(index + 1, point.x + 12, point.y - 8);
            });

            for (let i = 0; i < points.length - 1; i++) {
                ctx.shadowColor = '#64ffda';
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.moveTo(points[i].x, points[i].y);
                ctx.lineTo(points[i + 1].x, points[i + 1].y);
                ctx.strokeStyle = '#64ffda';
                ctx.lineWidth = 3;
                ctx.stroke();
                ctx.shadowBlur = 0;
            }
            
            if (points.length >= 2) {
                calculateDistances();
            }
        }

        canvas.addEventListener('click', function(e) {
            if (!image || points.length >= 4) return;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            
            points.push({ x, y });
            document.getElementById('pointCount').textContent = `${points.length}/4`;
            drawImage();
            
            if (points.length === 2 && !isCalibrated) {
                document.getElementById('setRefBtn').disabled = false;
                document.getElementById('calibStatus').textContent = 'Ready! Click "Calibrate"';
                document.getElementById('calibStatus').style.color = '#00f7ff';
            }
            
            console.log(`Point ${points.length} added at (${x.toFixed(2)}, ${y.toFixed(2)})`);
        });
        
        function setReference() {
            if (points.length < 2) {
                alert('Please click 2 points first!');
                return;
            }
            
            const dx = points[1].x - points[0].x;
            const dy = points[1].y - points[0].y;
            const pixelDistance = Math.sqrt(dx * dx + dy * dy);
            
            const refLength = parseFloat(document.getElementById('referenceLength').value);
            pixelsPerInch = pixelDistance / refLength;
            isCalibrated = true;
            
            document.getElementById('scaleFactor').value = pixelsPerInch.toFixed(2);
            document.getElementById('calibStatus').textContent = 'âœ“ Calibrated! Add more points to measure';
            document.getElementById('calibStatus').style.color = '#64ffda';
            document.getElementById('setRefBtn').disabled = true;
            
            calculateDistances();
            
            console.log(`âœ… Calibrated: ${pixelsPerInch.toFixed(2)} px/inch`);
        }

        function calculateDistances() {
            const container = document.getElementById('measurementsContainer');
            container.innerHTML = '';
            
            if (!isCalibrated) {
                const warningDiv = document.createElement('div');
                warningDiv.className = 'stat-item';
                warningDiv.innerHTML = `
                    <span class="stat-label" style="color: #ff6b6b;">âš  Not calibrated</span>
                    <span class="stat-value">Calibrate first</span>
                `;
                container.appendChild(warningDiv);
                return;
            }
            
            let totalPixels = 0;
            let totalReal = 0;
            
            for (let i = 0; i < points.length - 1; i++) {
                const dx = points[i + 1].x - points[i].x;
                const dy = points[i + 1].y - points[i].y;
                const pixelDistance = Math.sqrt(dx * dx + dy * dy);
                
                const realDistance_in = pixelDistance / pixelsPerInch;
                
                totalPixels += pixelDistance;
                totalReal += realDistance_in;
                
                const measureDiv = document.createElement('div');
                measureDiv.className = 'stat-item';
                measureDiv.innerHTML = `
                    <span class="stat-label">Segment ${i + 1} (${i + 1}â†’${i + 2}):</span>
                    <span class="stat-value">${pixelDistance.toFixed(2)} px | ${realDistance_in.toFixed(3)} in</span>
                `;
                container.appendChild(measureDiv);
            }
            
            if (points.length >= 2) {
                const totalDiv = document.createElement('div');
                totalDiv.className = 'stat-item';
                totalDiv.style.marginTop = '12px';
                totalDiv.style.borderTop = '1px solid rgba(100, 255, 218, 0.2)';
                totalDiv.style.paddingTop = '12px';
                totalDiv.innerHTML = `
                    <span class="stat-label" style="color: #64ffda; font-weight: 600;">Total Distance:</span>
                    <span class="stat-value" style="color: #64ffda; font-weight: 600;">${totalPixels.toFixed(2)} px | ${totalReal.toFixed(3)} in</span>
                `;
                container.appendChild(totalDiv);
            }
        }

        function resetPoints() {
            points = [];
            pixelsPerInch = null;
            isCalibrated = false;
            document.getElementById('pointCount').textContent = '0/4';
            document.getElementById('measurementsContainer').innerHTML = '';
            document.getElementById('scaleFactor').value = 'Not calibrated';
            document.getElementById('calibStatus').textContent = 'Click 2 points first';
            document.getElementById('calibStatus').style.color = '#64ffda';
            document.getElementById('setRefBtn').disabled = true;
        }

        function resetCalculation() {
            resetPoints();
            if (image) drawImage();
        }

        window.addEventListener('beforeunload', () => {
            points = [];
            image = null;
        });
    </script>
</body>
</html>
